//@ts-nocheck
let isClassComponent = function(element) {
  return element.toString().startsWith("class");
};
const memoizes = new Map;
globalThis.isServer = typeof window === "undefined";
globalThis.params = {
  [Symbol.iterator]: function* () {
    for (const key in this) {
      yield [key, this[key]];
    }
  }
};
if (typeof window === "undefined") {
  globalThis.localStorage = [];
  globalThis.sessionStorage = {
    getItem: (key) => {
      return globalThis.localStorage[key];
    },
    setItem: (key, value) => {
      globalThis.localStorage[key] = value;
    }
  };
  globalThis.window = {
    addEventListener: () => {
    },
    removeEventListener: () => {
    },
    dispatchEvent: () => {
    },
    navigator: {
      userAgent: "node"
    }
  };
}
export const useFetch = (url, options) => {
  return [null, true, null];
};
export const useAsyncState = (promise) => {
  return [null, () => {
  }];
};
export const useEffect = (callback, dependencies) => {
  dependencies = dependencies.map((dep) => dep.toString());
  if (dependencies.length === 0) {
    callback();
  }
};
export const Fragment = (props, children) => {
  return {
    type: "div",
    props: props || {},
    children: children || []
  };
};
globalThis.Fragment = Fragment;
export const e = (element, props, ...children) => {
  let instance;
  switch (true) {
    case isClassComponent(element):
      instance = new element;
      instance.props = props;
      instance.children = children;
      return instance.render(props);
    case typeof element === "function":
      instance = new Component;
      instance.render = element;
      return instance.render();
    default:
      return { type: element, props: props || {}, children: children || [] };
  }
};
export const useState = (initialState) => {
  const setState = (newState) => {
    initialState = newState;
  };
  return [initialState, setState];
};

export class Component {
  props;
  state;
  element;
  Mounted;
  effect;
  key;
  prevState;
  constructor() {
    this.key = Math.random().toString(36).substring(7);
    this.props = {};
    this.state = {};
    this.effect = [];
    this.Mounted = false;
    this.element = null;
  }
  useEffect(callback, dependencies) {
    if (dependencies.length === 0 && this.Mounted && this.effect.length === 0) {
      callback();
      this.effect.push(callback);
    } else {
      for (let i = 0;i < dependencies.length; i++) {
        if (this.effect[i] !== dependencies[i]) {
          this.effect = dependencies;
          callback();
        }
      }
    }
  }
  useState(key, defaultValue) {
    if (typeof window === "undefined")
      return [defaultValue, () => {
      }];
    let value = sessionStorage.getItem("state_" + key) ? JSON.parse(sessionStorage.getItem("state_" + key)).value : defaultValue;
    if (typeof value === "string") {
      try {
        value = JSON.parse(value);
      } catch (error) {
      }
    }
    if (!window["listener" + key] && !isServer) {
      window["listener" + key] = true;
      window.addEventListener("beforeunload", () => {
        sessionStorage.removeItem("state_" + key);
      });
    }
    const setValue = (newValue) => {
      alert(key);
      value = newValue;
      sessionStorage.setItem("state_" + key, JSON.stringify({ type: typeof newValue, value: newValue }));
      console.log(this.key)
      this.forceUpdate(this.key);
    };
    return [value, setValue];
  }
  useFetch(url, options) {
    const loadingKey = "loading_" + url;
    const errorKey = "error" + url;
    const dataKey = "_data" + url;
    let [loading, setLoading] = this.useState(loadingKey, true);
    let [error, setError] = this.useState(errorKey, null);
    let [data, setData] = this.useState(dataKey, null);
    console.log(loading, error, data);
    if (loading && !error && !data) {
      fetch(url, options).then((res) => res.json()).then((data) => {
        console.log(data);
        setLoading(false);
        setData(data); 
      }).catch((err) => {
        setError(err); 
      });
    }
    return [data, loading, error];
  }
  forceUpdate(key) {
    let el = Array.from(document.querySelectorAll("*")).filter((el2) => {
      return el2.key === key;
    })[0];
    console.log(el)
    if (el) {
      let newEl = this.toElement();
      el.replaceWith(newEl);
    }
  } 

Reconciler = {
    update: (oldElement, newElement) => {
        if (!oldElement || !newElement) return;

        // Check if the element itself needs to be updated
        if (this.Reconciler.shouldUpdate(oldElement, newElement)) {
            oldElement.replaceWith(newElement);
        } else if (oldElement.tagName === newElement.tagName) {
            // Update attributes
            this.Reconciler.updateAttributes(oldElement, newElement);

            // Update children recursively
            const oldChildren = Array.from(oldElement.childNodes);
            const newChildren = Array.from(newElement.childNodes);
            
            for (let i = 0; i < Math.max(oldChildren.length, newChildren.length); i++) {
                this.Reconciler.update(oldChildren[i], newChildren[i]);
            }
        }
    },

    updateAttributes: (oldElement, newElement) => {
        const oldAttrs = oldElement.attributes;
        const newAttrs = newElement.attributes;

        // Update existing attributes or add new ones
        for (let i = 0; i < newAttrs.length; i++) {
            const attr = newAttrs[i];
            if (oldElement.getAttribute(attr.name) !== attr.value) {
                oldElement.setAttribute(attr.name, attr.value);
            }
        }

        // Remove old attributes not present in the new element
        for (let i = 0; i < oldAttrs.length; i++) {
            const attr = oldAttrs[i];
            if (!newElement.hasAttribute(attr.name)) {
                oldElement.removeAttribute(attr.name);
            }
        }
    },

    shouldUpdate: (oldElement, newElement) => {
        if (oldElement.nodeType !== newElement.nodeType) return true;
        if (oldElement.nodeType === 3 && newElement.nodeType === 3) {
            return oldElement.textContent !== newElement.textContent;
        }
        if (oldElement.nodeName !== newElement.nodeName) return true;
        if (oldElement.childNodes.length !== newElement.childNodes.length) return true;

        // Check for attribute differences
        const oldAttrs = oldElement.attributes;
        const newAttrs = newElement.attributes;

        if (oldAttrs.length !== newAttrs.length) return true;

        for (let i = 0; i < newAttrs.length; i++) {
            const attr = newAttrs[i];
            if (oldElement.getAttribute(attr.name) !== attr.value) return true;
        }

        return false;
    }
};

  parseToElement = (element) => {
    if (!element)
      return document.createElement("div");
    let el = document.createElement(element.type);
    let isText = typeof element === "string" || typeof element === "number" || typeof element === "boolean";
    if (isText) {
      el.textContent = element;
    } else {
      let attributes = element.props;
      let children = element.children;
      for (let key in attributes) {
        if (key === "key") {
          el.key = attributes[key];
          continue;
        }
        if (key === "className") {
          el.className = attributes[key];
          continue;
        }
        if (key === "style") {
          for (let styleKey in attributes[key]) {
            el.style[styleKey] = attributes[key][styleKey];
          }
          continue;
        }
        if (key.startsWith("on")) {
          el.addEventListener(key.substring(2).toLowerCase(), attributes[key]);
          continue;
        }
        el.setAttribute(key, attributes[key]);
      }
      for (let i = 0;i < children.length; i++) {
        let child = children[i];
        if (Array.isArray(child)) {
          child.forEach((c) => {
            el.appendChild(this.parseToElement(c));
          });
        }
        if (typeof child === "function") {
          el.appendChild(this.parseToElement(child()));
        } else if (typeof child === "object") {
          el.appendChild(this.parseToElement(child));
        } else {
          let span = document.createElement("span");
          span.innerHTML = child;
          el.appendChild(span);
        }
      }
    }
    return el;
  };
  e(element, props, ...children) {
    if (typeof element === "function") {
      return element();
    }
    return { type: element, props: props || {}, children: children || [] };
  }
  toElement() {
    let children = this.render();
    if (children.props["key"]) {
      this.key = children.props["key"];
    }
    let el = this.parseToElement(children);
    el.key = this.key;
    return el;
  }
  render() {
    return "";
  }
}
function memoizeClassComponent(Component) {
  let key = Component.toString();
  if (memoizes.has(key)) {
    return memoizes.get(key);
  }
  let instance = new Component;
  memoizes.set(key, instance);
  return instance;
}
export function render(element, container) {
  if (isClassComponent(element)) {
    const instance = new element;
    instance.Mounted = true;
    let el = instance.toElement();
    instance.element = el;
    container.innerHTML = "";
    container.replaceWith(el);
  } else {
    let memoizedInstance = memoizeClassComponent(Component);
    memoizedInstance.Mounted = true;
    memoizedInstance.render = element.bind(memoizedInstance);
    let el = memoizedInstance.toElement();
    container.innerHTML = "";
    container.replaceWith(el);
  }
}
